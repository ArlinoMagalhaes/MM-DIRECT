#!/usr/bin/env python

# Generates a graphic from the dataset generated in Redis Instant Recovery (Redis IR).
# The graphic shows the database transaction throughput (number of commands executed) over time (seconds).
# The graphic is generated by a dataset is a CSV file containing the fields key,command,startTime,finishTime and type. 
# Each line of the CSV file represents a command execution on database.

# The three first CSV data lines are not executed commands or record flushed to indexed log, 
# they are the time (in seconds) of database startup, recovery, and benchmark execution. 
# When the time is not obtained, the value is -1.
#    Belows the fields used (1) executed commands (2) records flushed to indexed log CSV files:
#    (1) key                    commands        startTime           finishTime          type
#    (2) startTime              finishTime      recordsProcessed    recordsIndexed      type
#        "Database startup"                     <obtained time>                         0
#        "Shutdown"                             <obtained time>                         0
#        "Recovery"                             <obtained time>     <obtained time>     0
#        "Benchmark"                            <obtained time>     <obtained time>     0
    
#    Checkpoint process information is stored before the commands executed as bellows:
#    (1) key               command           startTime           finishTime         type
#    (2) startTime         finishTime        recordsProcessed    recordsIndexed      type
#       "Checkpoint"       <idCheckpoint>    <obtained time>     <obtained time>     0
#       "Checkpoint End"   <idCheckpoint>                        <obtained time>     0

#    The remaind CSV data lines are really executed commands.
#    (1) key               command               startTime           finishTime          type
#        <command key>     <command performed>   <obtained time>     <obtained time>     <command type>
#    (2) startTime         finishTime        recordsProcessed    recordsIndexed      type
#        <obtained time>   <obtained time>   <obtained number>   <obtained number>  

#path = path to dataset
def processDataIndexing(path, start_time):
    data = open(path).readlines()

    #Counts the lines of the dataset
    total = len(data)
    
    #Gets the database start up time
    ln = data[1].split(",")
    database_startup_time = int(ln[2])
    
    
    #Removes header and database Recoverystart up information
    data.pop(0)
    data.pop(0)
    data.pop(0)

    '''
        Creates a list of items from column 'endTime' (in microseconds) of the dataset 
        and converts all items to seconds. Additionally, these items are converted to 
        relative time to the  database start up time, i.e, the  database start up time 
        will be the zero time. 
    '''
    x_aux = []
    y_aux = []
    database_startup = 0
    database_recovery = 0
    otherElements = []  
    for i in range(len(data)):
        linha = data[i].split(",")
        if linha[0].isnumeric() and int(linha[0]) > 0:
            num =  (int(linha[1]) - database_startup_time)/1000000#finishTime
            x_aux.append(int(num))
            y_aux.append(int(linha[3]))#number of records indexed
        else:   #   Stores the database startup time, system restart time, recovery time, or bechmark finish time.
            element = []
            if linha[0] == "Database startup":
                element.append("System restart")
                num = float((int(linha[2]) - database_startup_time)/1000000)#startTime
                element.append(num)
                database_startup = num
            else:
                if linha[0] == "Shutdown":
                    element.append("System failure")
                    num = float((int(linha[2]) - database_startup_time)/1000000)#startTime
                    element.append(num)
                else:
                    if linha[0] == "Recovery":
                        num = float((int(linha[2]) - database_startup_time)/1000000)#startTime
                        if num > 0:
                            element.append("Recovery")
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)#finishTime
                            element.append(num)
                            database_recovery = num
                    else:
                        if linha[0] == "Benchmark":
                            element.append("Benchmark")
                            num = float((int(linha[2]) - database_startup_time)/1000000)#startTime
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)#finishTime
                            element.append(num)
                        else:
                            if linha[0] == "Checkpoint":
                                element.append("Checkpoint")  # Checkpoint
                                #element.append(linha[1])  # checkpoint ID
                                element.append((int(linha[2])-database_startup_time)/1000000) #startTime
                                element.append((int(linha[3])-database_startup_time)/1000000) #finishTime
            if element:
                otherElements.append(element)

    x = list(range(0, max(x_aux))) # List from zero to maximum end of time 
    y = [0] * max(x_aux) # List o zeros
    j = 0
    i = 0
    maxList = len(x)
    while i < maxList:
        if x[i] == x_aux[j]:
            y[i] += y_aux[j]
            j += 1
        else:
            i += 1

    return x, y, otherElements

#path = path to dataset
def processDataLogging(path, start_time):
    data = open(path).readlines()

    #Counts the lines of the dataset
    total = len(data)
    
    #Gets the database start up time
    ln = data[1].split(",")
    database_startup_time = int(ln[2])
    
    
    #Removes header and database Recoverystart up information
    data.pop(0)
    data.pop(0)

    '''
        Creates a list of items from column 'endTime' (in microseconds) of the dataset 
        and converts all items to seconds. Additionally, these items are converted to 
        relative time to the  database start up time, i.e, the  database start up time 
        will be the zero time. 
    '''
    endTimeList = []    #   Stores the endTime of a performed command.
    otherElements = []  
    for i in range(len(data)):
        linha = data[i].split(",")
        if linha[5] != "0\n" and linha[1].upper() == "SET":   #   Stores the endTime of a performed command.
            if linha[3].isnumeric():#   prevents to a possible corrupted data
                num =  int((int(linha[3]) - database_startup_time)/1000000)
               # if num >= start_time:
                endTimeList.append(num)
        else:   #   Stores the database startup time, system restart time, recovery time, or bechmark finish time.
            element = []
            if linha[0] == "Database startup":
                element.append("System restart")
                num = float((int(linha[2]) - database_startup_time)/1000000)
                element.append(num)
            else:
                if linha[0] == "Shutdown":
                    element.append("System failure")
                    num = float((int(linha[2]) - database_startup_time)/1000000)
                    element.append(num)
                else:
                    if linha[0] == "Recovery":
                        num = float((int(linha[2]) - database_startup_time)/1000000)
                        if num > 0:
                            element.append("Recovery")
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)
                            element.append(num)
                    else:
                        if linha[0] == "Benchmark":
                            element.append("Benchmark")
                            num = float((int(linha[2]) - database_startup_time)/1000000)
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)
                            element.append(num)
                        else:
                            if linha[0] == "Checkpoint":
                                element.append("Checkpoint")  # Checkpoint
                                element.append(linha[1])  # checkpoint ID
                                element.append((int(linha[2])-database_startup_time)/1000000) #   start time
                                element.append((int(linha[3])-database_startup_time)/1000000) #   end time
                            else:
                                if linha[0] == "Checkpoint End":
                                    element.append("Checkpoint End")  #  End of the checkpoint
                                    element.append(linha[1])  #   checkpoint ID
                                    element.append((int(linha[3])-database_startup_time)/1000000) #   end time
            if element:
                otherElements.append(element)

    endTimeList.sort();


    x = list(range(0, max(endTimeList))) # List from zero to maximum end of time 
    y = [0] * max(endTimeList) # List o zeros

    # Stores in y the number items in x that are in endTimeList
    j = 0
    i = 0
    maxList = len(x)
    while i < maxList:
        if x[i] == endTimeList[j]:
            y[i] += 1
            j += 1
        else:
            i += 1

    #   Shifts the begining of the graphic to start_time
    if start_time > 0:
        del x[:start_time]
        del y[:start_time]
        for i in range(len(x)):
            x[i] = i
        for i in range(len(otherElements)-1):
            line = otherElements[i]
            if line[0] == "System restart" or line[0] == "System failure":
                line[1] = line[1] - start_time
            if line[0] == "Recovery" or line[0] == "Benchmark":
                line[1] = line[1] - start_time
                line[2] = line[2] - start_time
            if line[0] == "Checkpoint":
                line[2] = line[2] - start_time
                line[3] = line[3] - start_time
            if line[0] == "Checkpoint End":
                line[2] = line[2] - start_time

    print("Total of lines from dataset:", total)
    print("Graphic: X lines = ", len(x), ", Y lines = ", len(y))

    return x, y, otherElements

import matplotlib.pyplot as plt

def printGraphic(x1_data, y1_data, otherElements1, cor1, legend1, x2_data, y2_data, otherElements2, cor2, legend2):
    plt.figure(figsize=(16,8))

    #plt.rc('font', size=16) 
    #plt.rc('axes', titlesize=20)     # fontsize of the axes title
    #plt.rc('axes', labelsize=20)    # fontsize of the x and y labels
    #plt.rc('xtick', labelsize=20)    # fontsize of the tick labels
    #plt.rc('ytick', labelsize=20)    # fontsize of the tick labels
    #plt.rc('legend', fontsize=20)    # legend fontsize
    #plt.rc('figure', titlesize=20)  # fontsize of the figure title

    plt.plot(x1_data, y1_data, color = cor1, label = legend1)
    plt.plot(x2_data, y2_data, color = cor2, label = legend2)
    
    
    plt.grid(True)
    plt.xlabel("Time (seconds)")
    plt.ylabel("Average of records written")
    
    handles, labels = plt.gca().get_legend_handles_labels()
    order = [1, 0]
    leg = plt.legend([handles[idx] for idx in order],[labels[idx] for idx in order])
    leg.get_frame().set_edgecolor('black')
    
    y_max = max(y1_data)
    if max(y2_data) > y_max:
        y_max = max(y2_data)

    if otherElements1:
        x_scatter1 = []
        y_scatter1 = []
        for i in range(len(otherElements1)-1):
            line = otherElements1[i]
            if line[0] == "System restart":
                x_scatter1.append(line[1])
                y_scatter1.append(y_max/10)
                plt.text(line[1], y_max/10, str(round(line[1], 2)) + 's \n(System Restart)', ha='left', va='center')
                print("System restart = " + str(line[1]) + " seconds")
            else:
                if line[0] == "System failure":
                    plt.text(line[1], y_max, 'System failure', ha='center', va='baseline', weight="bold")
                    plt.text(line[1], y_max, str(round(line[1], 2)) + 's', ha='left', va='top')
                    plt.axvline(x=line[1], linestyle='dotted', color='r', linewidth=3)
                    x_scatter1.append(line[1])
                    y_scatter1.append(y_max)
                    print("System failure1 = " + str(line[1]) + "seconds" )
                else:
                    if line[0] == "Recovery":
                        x_scatter1.append(line[2])
                        y_scatter1.append(y_max/5)
                        plt.text(line[2], y_max/5, str(round(line[2],2)) + 's\n(Recovery Time)', ha='left', va='top')
                        plt.axvline(x=line[2], linestyle='dotted', color=cor1)
                        print("Recovery1: start" + str(line[1]) + "seconds , finish = " + str(line[2]) + " seconds")
                    else:
                        if line[0] == "Benchmark":
                            print("Benchmark1: start = " + str(line[1]) + "seconds , finish = " + str(line[2]) + " seconds")
                        else:
                            if(line[0] == "Checkpoint"):
                                plt.text((line[3]+line[2])/2, y_max/2,'Checkpoint \n'+str(round(line[3]-line[2],2))+'s', ha='center', va='bottom')
                                plt.hlines(y=y_max/2, xmin=line[2], xmax=line[3], linewidth=2, color=cor1)
                                plt.annotate ('', (line[1], y_max/2), (line[2], y_max/2), arrowprops={'arrowstyle':'|-|'}, color=cor1)
                                plt.text(line[1],y_max/2, str(round(line[1], 2))+'s', ha='right', va='top')
                                plt.text(line[2],y_max/2, str(round(line[2], 2))+'s', ha='left', va='top')

                                print("Checkpoint: (1)")
                                print("     start time = ", line[2], "seconds")
                                print("     finish time = ", line[3], "seconds")
                                print("     time interval = ", line[3]- line[2], "seconds")
        plt.scatter(x_scatter1, y_scatter1, color = 'black')

    if otherElements2:
        x_scatter1 = []
        y_scatter1 = []
        for i in range(len(otherElements2)-1):
            line = otherElements2[i]
            if line[0] == "System failure":
                #plt.text(line[1], y_max, 'System failure', ha='center', va='baseline', fontsize=16, weight="bold")
                #plt.text(line[1], y_max, str(round(line[1], 2)) + 's', ha='left', va='top')
                #plt.axvline(x=line[1], linestyle='dotted', color='r', linewidth=3)
                #x_scatter1.append(line[1])
                #y_scatter1.append(y_max)
                print("System failure2 = " + str(line[1]) + "seconds" )
            else:
                if line[0] == "Recovery":
                    '''
                    x_scatter1.append(line[2])
                    y_scatter1.append(y_max/3)
                    plt.text(line[2], y_max/3, str(round(line[2],2)) + 's(Recovery Time)', ha='left', va='top', color='black')
                    plt.axvline(x=line[2], linestyle='dashed', color=cor2)    
                    '''
                    print("Recovery2: start" + str(line[1]) + "seconds , finish = " + str(line[2]) + " seconds")
                else:
                    if line[0] == "Checkpoint":
                        plt.text((line[3]+line[2])/2, y_max/2,'Checkpoint '+str(line[1])+'\n'+str(round(line[3]-line[2],2))+'s', ha='center', va='bottom')
                        plt.hlines(y=y_max/2, xmin=line[2], xmax=line[3], linewidth=2, color=cor)
                        plt.annotate ('', (line[2], y_max/2), (line[3], y_max/2), arrowprops={'arrowstyle':'|-|'}, color=cor)
                        plt.text(line[2],y_max/2, str(round(line[2], 2))+'s', ha='right', va='top')
                        plt.text(line[3],y_max/2, str(round(line[3], 2))+'s', ha='left', va='top')

                        print("Checkpoint ", line[1], ": (2)")
                        print("     start time = ", line[2], "seconds")
                        print("     finish time = ", line[3], "seconds")
                        print("     time interval = ", line[3]- line[2], "seconds")
        plt.scatter(x_scatter1, y_scatter1, color = cor2)


def processAverageData(x_data, y_data, range):
    x = []
    y = []

    k = 0
    y_count = 0
    max = len(y_data)
    i = 0
    while i < max:
        y_count = y_count + y_data[i]
        k = k + 1
        if k == int(range):
            y.append(y_count/k)
            x.append(x_data[i])
            y_count = 0
            k = 0
        i = i + 1

    return x, y


def ChooseFileIndexing():
    from tkinter.filedialog import askopenfilename
    return askopenfilename(initialdir = "../indexing_report",title = "Select file",filetypes = (("text file","*.csv"),("all files","*.*")))


def ChooseFileLogging():
    from tkinter.filedialog import askopenfilename
    return askopenfilename(initialdir = "../datasets",title = "Select file",filetypes = (("text file","*.csv"),("all files","*.*")))

print("Choose the dataset file (indexing)!")
filename = ChooseFileIndexing()
print("Chosen file: ", filename)

print("Choose the dataset file (logging)!")
filename2 = ChooseFileLogging()
print("Chosen file: ", filename2)

print("\nReading the dataset 01 ... Wait!\n")
x_data = []
y_data = []
otherElements1 = []

x_data, y_data, otherElements1 = processDataIndexing(filename, 0)

print("Average Y1 = ", sum(y_data) / float(len(y_data)) )

x_data, y_data = processAverageData(x_data,y_data, 5)

print("\nReading the dataset 02 ... Wait!\n")

x_data2, y_data2, otherElements2 = processDataLogging(filename2, 0)

print("Average Y2 = ", sum(y_data2) / float(len(y_data2)) )

x_data2, y_data2 = processAverageData(x_data2,y_data2, 5)

print("Graphic2: X lines = ", len(x_data2), ", Y lines = ", len(y_data2))

print("Printing the graphic ...")

#otherElements1 = []
#otherElements2 = []

printGraphic(x_data, y_data, otherElements1,  'blue', 'Average indexing rate in indexed log', x_data2, y_data2, otherElements2, 'orange', 'Average write rate in sequential log')

print("Graphic ploted in another window!")
plt.show()