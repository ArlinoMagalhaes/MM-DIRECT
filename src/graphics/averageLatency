#!/usr/bin/env python

# Generates a graphic from the dataset generated in Redis Instant Recovery (Redis IR).
# The graphic shows the latency over time (seconds).
# The graphic is generated by a dataset is a CSV file containing the fields key, command,
# startTime, finishTime and type. 
# Each line of the CSV file represents a command execution on database.

# The three first CSV data lines are not executed commands, they are the time (in seconds) of database startup, recovery, 
# and benchmark execution. When thetime is not obtained, the value is -1.
#    Belows the fields used:
#        key                        commands    startTime           finishTime          type
#        "Database startup"                     <obtained time>                         0
#        "Shutdown"                             <obtained time>                         0
#        "Recovery"                             <obtained time>     <obtained time>     0
#        "Benchmark"                            <obtained time>     <obtained time>     0
    
#    Checkpoint process information is stored before the commands executed as bellows:
#        key               command           startTime           finishTime         type
#       "Checkpoint"       <idCheckpoint>    <obtained time>     <obtained time>     0
#       "Checkpoint End"   <idCheckpoint>                        <obtained time>     0

#    The remaind CSV data lines are really executed commands.
#        key               command               startTime           finishTime          type
#        <command key>     <command performed>   <obtained time>     <obtained time>     <command type>


#path = path to dataset
def processData(path, start_time):
    data = open(path).readlines()

    #Counts the lines of the dataset
    total = len(data)
    
    #Gets the database start up time
    ln = data[1].split(",")
    database_startup_time = int(ln[2])
    
    
    #Removes header and database Recoverystart up information
    data.pop(0)
    data.pop(0)

    '''
        Creates a list of items from column 'endTime' (in microseconds) of the dataset 
        and converts all items to seconds. Additionally, these items are converted to 
        relative time to the  database start up time, i.e, the  database start up time 
        will be the zero time. 
    '''
    database_startup = 0
    database_recovery = 0
    x = []
    y = []
    otherElements = []  
    for i in range(len(data)):
        linha = data[i].split(",")
        if linha[5] != "0\n":   #   Stores the endTime of a performed command.
            if linha[3].isnumeric():#   prevents to a possible corrupted data
                num =  int((int(linha[3]) - database_startup_time)/1000000)
                x.append(num) #finishTime
                y.append(int(linha[4]))
        else:   #   Stores the database startup time, system restart time, recovery time, or bechmark finish time.
            element = []
            if linha[0] == "Database startup":
                element.append("System restart")
                num = float((int(linha[2]) - database_startup_time)/1000000)
                element.append(num)
                database_startup = num
            else:
                if linha[0] == "Shutdown":
                    element.append("System failure")
                    num = float((int(linha[2]) - database_startup_time)/1000000)
                    element.append(num)
                else:
                    if linha[0] == "Recovery":
                        num = float((int(linha[2]) - database_startup_time)/1000000)
                        if num > 0:
                            element.append("Recovery")
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)
                            element.append(num)
                            database_recovery = num
                    else:
                        if linha[0] == "Benchmark":
                            element.append("Benchmark")
                            num = float((int(linha[2]) - database_startup_time)/1000000)
                            element.append(num)
                            num = float((int(linha[3]) - database_startup_time)/1000000)
                            element.append(num)
                        else:
                            if linha[0] == "Checkpoint":
                                element.append("Checkpoint")  # Checkpoint
                                element.append(linha[1])  # checkpoint ID
                                element.append((int(linha[2])-database_startup_time)/1000000) #   start time
                                element.append((int(linha[3])-database_startup_time)/1000000) #   end time
                            else:
                                if linha[0] == "Checkpoint End":
                                    element.append("Checkpoint End")  #  End of the checkpoint
                                    element.append(linha[1])  #   checkpoint ID
                                    element.append((int(linha[3])-database_startup_time)/1000000) #   end time
            if element:
                otherElements.append(element)
    
    new_x = []
    new_y = []
    count_y = []
    distinct_y = []
    for i in range(0, max(x)+1):
        new_x.append(i)
        new_y.append(0)
        count_y.append(0)
        distinct_y.append(0)

    sum_latency_before_database_startup = 0
    sum_latency_after_database_recovery = 0
    sum_latency_during_database_recovery = 0
    total1 = 0
    total2 = 0
    total3 = 0
    for i in range(len(data)):
        linha = data[i].split(",")
        if linha[5] != "0\n":   #   Stores the endTime of a performed command.
            if linha[3].isnumeric():#   prevents to a possible corrupted data
                time =  int((int(linha[3]) - database_startup_time)/1000000)
                latency = int(linha[4])
                new_y[time] = new_y[time] + latency
                count_y[time] = count_y[time] + 1
                if time <= database_startup:
                    sum_latency_before_database_startup = sum_latency_before_database_startup + latency
                    total1 = total1 + 1
                else:
                    if time >= database_recovery:
                        sum_latency_after_database_recovery = sum_latency_after_database_recovery + latency
                        total2 = total2 + 1
                    else:
                        sum_latency_during_database_recovery = sum_latency_during_database_recovery + latency
                        total3 = total3 + 1
    
    for i in  range(len(count_y)):
        if count_y[i] != 0:
            new_y[i] = new_y[i]/count_y[i]

    
    print("Total of lines from dataset:", total)
    print("Graphic: X lines = ", len(new_x), ", Y lines = ", len(new_y), "count_y", len(count_y))
    '''
    i = 0
    end = len(count_y)
    while i < end:
        if count_y[i] == 0:
            print("removed ", count_y[i])
            del count_y[i]
            del new_y[i]
            del new_x[i]
            end = len(count_y)
        else:
            i = i + 1
    '''
    if total1 != 0:
        print("avarage latency before database startup = ", sum_latency_before_database_startup/total1)
    if total2 != 0:
        print("avarage latency after database recovery = ", sum_latency_after_database_recovery/total2)
    if total3 != 0:
        print("avarage latency during database recovery = ", sum_latency_during_database_recovery/total3)
    print("avarage latency = ", (sum_latency_before_database_startup + sum_latency_after_database_recovery + sum_latency_during_database_recovery)/(total1 + total2 + total3))

    return new_x, new_y, otherElements

import matplotlib.pyplot as plt

def printGraphic(x1_data, y1_data, otherElements1, cor1, legend1):
    plt.figure(figsize=(16,8))

    #plt.rc('font', size=16) 
    #plt.rc('axes', titlesize=20)     # fontsize of the axes title
    #plt.rc('axes', labelsize=20)    # fontsize of the x and y labels
    #plt.rc('xtick', labelsize=20)    # fontsize of the tick labels
    #plt.rc('ytick', labelsize=20)    # fontsize of the tick labels
    #plt.rc('legend', fontsize=20)    # legend fontsize
    #plt.rc('figure', titlesize=20)  # fontsize of the figure title

    plt.plot(x1_data, y1_data, color = cor1, label = legend1)

    y_max = max(y1_data)

    print("Highest average latency = ", y_max)

    if otherElements1:
        x_scatter1 = []
        y_scatter1 = []
        for i in range(len(otherElements1)-1):
            line = otherElements1[i]
            if line[0] == "System restart":
                x_scatter1.append(line[1])
                y_scatter1.append(y_max/10)
                plt.text(line[1], y_max/10, str(round(line[1], 2)) + 's \n(System Restart)', ha='left', va='center')
                print("System restart = " + str(line[1]) + " seconds")
            else:
                if line[0] == "System failure":
                    plt.text(line[1], y_max, 'System failure', ha='center', va='baseline', weight="bold")
                    plt.text(line[1], y_max, str(round(line[1], 2)) + 's', ha='left', va='top')
                    plt.axvline(x=line[1], linestyle='dashed', color='r', linewidth=3)
                    x_scatter1.append(line[1])
                    y_scatter1.append(y_max)
                    print("System failure = " + str(line[1]) + "seconds" )
                else:
                    if line[0] == "Recovery":
                        x_scatter1.append(line[2])
                        y_scatter1.append(y_max-y_max/2)
                        plt.text(line[2], y_max-y_max/2, str(round(line[2],2)) + 's\nRecovery Time', ha='left', va='top', color='black')
                        plt.axvline(x=line[2], linestyle='dashed', color=cor1, linewidth=3)
                        print("Recovery: start" + str(line[1]) + "seconds , finish = " + str(line[2]) + " seconds")
        plt.scatter(x_scatter1, y_scatter1, color = 'black')

    plt.grid(True)
    plt.xlabel("Time (seconds)")
    plt.ylabel("Average latency (microseconds)")
    
    print("Graphic ploted in another window!")
    plt.show()


def ChooseFile():
    from tkinter.filedialog import askopenfilename
    return askopenfilename(initialdir = "../datasets",title = "Select file",filetypes = (("text file","*.csv"),("all files","*.*")))


'''
import sys

print('Number of arguments:', len(sys.argv), 'arguments.')
print('Argument List:', str(sys.argv))
'''

print("Choose the dataset file 02!")
filename2 = ChooseFile()
print("Chosen file: ", filename2)

print("\nReading the dataset2 ... Wait!\n")
x2_data = []
y2_data = []
otherElements2 = []

x2_data, y2_data, otherElements2 = processData(filename2, 0)

printGraphic(x2_data, y2_data, otherElements2, 'blue', 'Instant recovery (IRAIL)')

